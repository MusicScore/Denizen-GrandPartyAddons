################################################################################
#                                                                              #
#                              ADVANCEDLIGHTS MAIN                             #
#                                                                              #
################################################################################
# 
# ----| ABOUT THIS SCRIPT
# 
# Performs most of the main functions for AdvancedLights. Includes creating
# lights and registering the click event.
# 
# 
# ----| CAVEAT
# 
# Due to the nature of this addon, any skull with the skins specified by the
# "gpa_advancedLights_data" script will be included in the script's functions.
# There is currently no way around it.
# 
# 


gpa_advancedLights_main:
  type: world
  debug: false
  version: '0.1.4.1'
  events:
    on server start:
    - inject locally 'events.on script reload' instantly

    on script reload:
    - ~webget 'https://raw.githubusercontent.com/MusicScore/Denizen-GrandPartyAddons/master/versions_list.txt' save:dscript_versions
    - if <entry[dscript_versions].failed||true> {
      - queue clear
    }
    - if <s@gpa_advancedLights_main.yaml_key[version]||null> == null {
      - narrate '<&c>An unsupported version of AdvancedLights has been detected! Consider downloading a legitimate version.'
      - queue clear
    }
    - define v '<entry[dscript_versions].result.split[;].map_get[advancedlights].split_by[:]||null>'
    - define vl 'li@<def[v]>|<s@gpa_advancedLights_main.yaml_key[version]||null>'
    - if <def[v]> != <s@gpa_advancedlights_main.yaml_key[version]> {
      - if <def[vl].alphanumeric.last> == <def[v]> {
        - narrate '<&c>Your version of AdvancedLights is outdated! Most updated version is <&4><def[v]><&r><&c>.'
        - queue clear
      }
      - narrate '<&c>Your version of AdvancedLights is unsupported or the version database has not been updated yet. Please refer to the issues page for all GrandPartyAddons for support.'
    }

    on player enters notable cuboid:
    - foreach <context.cuboids.filter[starts_with[gpa_advancedLights_]]> {
      - define id '<def[value].notable_name.after_last[_]>'
      - define loc '<server.flag[gpa.advancedLights.cuboids].as_list.map_get[<def[id]>]>'
      - foreach <server.list_flags[gpa.advancedLights.]> {
        - if <server.flag[<def[value]>].as_list.contains[<def[loc]>]||false> {
          - run gpa_advancedLights_main_light def:<def[loc]>|<def[value]>
        }
      }
    }
    on player places skull:
    - if <context.item_in_hand.material> != m@human_skull || <context.cancelled> {
      - queue clear
    }
    - define id '<util.random.uuid>'
    - foreach <s@gpa_advancedLights_data.list_keys[items]> {
      - if <player.item_in_hand.skin.full||null> != <s@gpa_advancedLights_data.yaml_key[items.<def[value]>.skull_skin]> {
        - foreach next
      }
      - light <context.location> <s@gpa_advancedLights_data.yaml_key[items.<def[value]>.light]||1>
      - flag server 'gpa.advancedLights.<s@gpa_advancedLights_data.yaml_key[items.<def[value]>.light]||1>:->:<context.location>'
      - define cub 'cu@<context.location.sub[80,80,80]>|<context.location.add[80,80,80]>'
      - flag server 'gpa.advancedLights.cuboids:->:<def[id]>/<context.location>'
      - note <def[cub].as_cuboid> as:gpa_advancedLights_<def[id]>
      - foreach stop
    }
    - if <server.list_scripts.contains[s@gpa_gpu_versionCheck]> {
      - define v '<proc[gpa_gpu_versionCheck]||1>'
    }
    else {
      - define v '1'
    }
    - if <def[v]> < 1 {
      - define ar 'cu@<player.location.block.sub[16,16,16]>|<player.location.block.add[16,16,16]>'
      - adjust <def[ar].list_partial_chunks> refresh_chunk_sections
    }
    on player breaks skull:
    - if <context.location.skull_type||null> != 'PLAYER' || <context.cancelled> {
      - queue clear
    }
    - foreach <server.list_flags[gpa.advancedLights.]> {
      - if <server.flag[<def[value]>].as_list.contains[<context.location>]||false> {
        - light <context.location> reset
        - flag server '<def[value]>:<-:<context.location>'
        - foreach <server.list_notables[cuboids]> {
          - if <def[value].center.block> == <context.location> {
            - define cub_n '<def[value].notable_name||null>'
            - flag server 'gpa.advancedLights.cuboids:->:<def[cub_n].after_last[_]>/<context.location>'
            - note remove as:<def[cub_n]>
          }
        }
      }
    }
    - if <server.list_scripts.contains[s@gpa_gpu_versionCheck]> {
      - define v '<proc[gpa_gpu_versionCheck]||1>'
    }
    else {
      - define v '1'
    }
    - if <def[v]> < 1 {
      - define ar 'cu@<player.location.block.sub[16,16,16]>|<player.location.block.add[16,16,16]>'
      - adjust <def[ar].list_partial_chunks> refresh_chunk_sections
    }
    - if <li@1|3.contains[<player.gamemode.id>]> {
      - queue clear
    }
    - foreach <s@gpa_advancedLights_data.list_keys[items]> {
      - if <context.location.skull_skin.full||null> != <s@gpa_advancedLights_data.yaml_key[items.<def[value]>.skull_skin]> {
        - foreach next
      }
      - define d_l '<s@gpa_advancedLights_data.yaml_key[items.<def[value]>.drops].as_list||li@>'
      - if <def[d_l].contains[self]||true> {
        - define self_skull 'i@human_skull[display_name=&ssf<def[value].replace[_].with[ ].to_titlecase>;skull_skin=<s@gpa_advancedLights_data.yaml_key[items.<def[value]>.skull_skin]>]'
        - define d_l '<def[d_l].exclude[self].parse[as_item].include[<def[self_skull]>]>'
      }
      - determine passively '<def[d_l]>'
    }
    on player right clicks skull using hand:
    - if <context.cancelled> {
      - queue clear
    }
    - foreach <s@gpa_advancedLights_data.list_keys[items]> {
      - if <context.location.skull_skin.full||null> != <s@gpa_advancedLights_data.yaml_key[items.<def[value]>.skull_skin]> {
        - foreach next
      }
      - if !<s@gpa_advancedLights_data.yaml_key[items.<def[value]>.click]||false> {
        - queue clear
      }
      - define li_lvl '<s@gpa_advancedLights_data.yaml_key[items.<def[value]>.light]||1>'
      - define cl '<s@gpa_advancedLights_data.yaml_key[items.<def[value]>.click_action]||null>'
      - if <def[cl]> == 'pickup' {
        - define p_i '<s@gpa_advancedLights_data.yaml_key[items.<def[value]>.pickup_item].as_item||i@stone>'
        - define p_s '<s@gpa_advancedLights_data.yaml_key[items.<def[value]>.pickup_sound].as_list||li@>'
        - if <player.inventory.can_fit[<def[p_i]>]> {
          - give <def[p_i]>
          - modifyblock <context.location> m@air
          - light <context.location> reset
          - flag server 'gpa.advancedLights.<def[li_lvl]>:<-:<context.location>'
          - if <def[p_s].is_empty> {
            - if <proc[gpa_gpu_versionCheck]||1> > 0 {
              - define p_s 'UI_BUTTON_CLICK|1'
            }
            else {
              - define p_s 'CLICK|1'
            }
          }
          - playsound <context.location> 'sound:<def[p_s].get[1]>' pitch:<def[p_s].get[2]>
        }
      }
      else if <def[cl]> == 'toggle' {
        - determine passively 'CANCELLED'
        - define t_s '<s@gpa_advancedLights_data.yaml_key[items.<def[value]>.toggle_sound].as_list||li@>'
        - if <def[t_s].is_empty> {
          - if <proc[gpa_gpu_versionCheck]||1> > 0 {
            - define t_s 'UI_BUTTON_CLICK|1|1'
          }
          else {
            - define t_s 'CLICK|1|1'
          }
        }
        - if <server.flag[gpa.advancedLights.<def[li_lvl]>].as_list.contains[<context.location>]||false> {
          - light <context.location> reset
          - flag server 'gpa.advancedLights.<def[li_lvl]>:<-:<context.location>'
          - playsound <context.location.center> 'sound:<def[t_s].get[1]>' volume:1 pitch:<def[t_s].get[3]>
        }
        else {
          - define t_li '<s@gpa_advancedLights_data.yaml_key[items.<def[value]>.toggle_items].as_list||li@>'
          - define c_h '<def[t_li].exclude[none].parse[as_material.name].contains[<player.item_in_hand.material.name>]||false>'
          - if <def[t_li].contains[none]> || <def[c_h]> {
            - light <context.location> <def[li_lvl]>
            - flag server 'gpa.advancedLights.<def[li_lvl]>:->:<context.location>'
            - if <def[c_h]> && <player.item_in_hand.durability.add_int[1]||1> < <player.item_in_hand.max_durability||0> && <li@0|2.contains[<player.gamemode.id>]> {
              - if <def[t_li].contains[none]||true> {
                - take iteminhand
              }
              else {
                - adjust <player.item_in_hand> 'durability:<player.item_in_hand.durability.add_int[1]>' save:tiu
                - adjust <player> 'item_in_hand:<entry[tiu].result>'
              }
            }
            - playsound <context.location.center> 'sound:<def[t_s].get[1]>' volume:1 pitch:<def[t_s].get[2]>
          }
        }
      }
      - if <server.list_scripts.contains[s@gpa_gpu_versionCheck]> {
        - define v '<proc[gpa_gpu_versionCheck]||1>'
      }
      else {
        - define v '1'
      }
      - if <def[v]> < 1 {
        - define ar 'cu@<player.location.block.sub[16,16,16]>|<player.location.block.add[16,16,16]>'
        - adjust <def[ar].list_partial_chunks> refresh_chunk_sections
      }
      - foreach stop
    }

gpa_advancedLights_main_light:
  type: task
  speed: 0
  debug: false
  definitions: loc|flag_name
  script:
  - repeat 599 {
    - if <def[loc].chunk.is_loaded> {
      - goto light
    }
    - wait 1t
  }
  - queue clear
  - mark light
  - light <def[loc]> '<def[flag_name].after_last[.]>'