###############################################################################
#                                                                             #
#                            FEVERDEATH MAIN SCRIPT                           #
#                                                                             #
###############################################################################
# 
# For a detailed description of FeverDeath, please check out the readme.txt
# that should have come with the complete set of FeverDeath script files.
# 
# 
# ----| ABOUT THIS SCRIPT
# 
# Welcome to the main file for FeverDeath! This file handles the actual
# functions of each module of FeverDeath. The priority each module gets is as
# follows:
# 
#   1. Death's Door
#   2. Afterlife
#   3. Thanatophobia
# 
# Even with the priority list above, none of the modules actually override each
# other. But, in the event that an update leads to the modules having
# conflicting functions, the priority list will be important to note.
# 
# 
# ----| CAVEATS
# 
# This entire file has been built to withstand most configuration errors that
# makes it past the checker in "gpa_feverDeath_config." Usually, such
# configuration errors can only be produced by using the Denizen "yaml"
# command.
#
# That being said, do NOT use the Denizen "yaml" command to edit values and
# options for FeverDeath. Just edit the configuration file and use "/feverdeath
# reload".
# 
# 
# ----| TO-DO LIST
# 
#  - Directly tamper with regular Golden Apples in terms of effects given upon
#    consumption. Super Golden Apples will be left as is.
#  - Curse of Binding increases ability of item to be preserved, but gives all
#    other items Curse of Vanishing.
#  - Curse of Vanishing (obviously) guarantees that the item will be lost, and
#    it will not be dropped.
#  - Introduced reduced health as a debuff and account for a varied max HP.
#  - Make the recovery phase debuffs stack up to a configurable amount of times
#    (6 being the absolute max, and 1 being the absolute min)
#  - Plausibly make a lore reader or custom enchantment listener that can
#    affect Afterlife inventory and EXP loss chances
#  - Make more options!
#    - Make more numbers configurable (e.g. hotbar persistence reduction)
#    - Make more events possible!
#    - Just make this entire addon completely customizable without having to
#      edit the scripts!
# 
# 


gpa_feverDeath_main:
  type: world
  debug: false
  events:
    on shutdown:
    - if !<server.list_scripts.parse[name].contains[gpa_feverDeath_config|gpa_feverDeath_ddRecovery|gpa_feverDeath_ddRecovery_timer_task|gpa_feverDeath_cmd]> {
      - queue clear
    }
    - run gpa_feverDeath_config

    on server start:
    - if !<server.list_scripts.parse[name].contains[gpa_feverDeath_config|gpa_feverDeath_ddRecovery|gpa_feverDeath_ddRecovery_timer_task|gpa_feverDeath_cmd]> {
      - queue clear
    }
    - run gpa_feverDeath_config

    on script reload:
    - wait 1t
    - if !<server.list_scripts.parse[name].contains[gpa_feverDeath_config|gpa_feverDeath_ddRecovery|gpa_feverDeath_ddRecovery_timer_task|gpa_feverDeath_cmd]> {
      - narrate '<&c>[FeverDeath] WARNING: Not all FeverDeath scripts are detected! Disabling FeverDeath.'
      - if <context.sender> != 'CONSOLE' {
        - announce '<&c>[FeverDeath] WARNING: Not all FeverDeath scripts are detected! Disabling FeverDeath.' 'to_console'
      }
      - queue clear
    }
    - run gpa_feverDeath_config

    on suicide|esuicide command:
    - if !<server.list_scripts.parse[name].contains[gpa_feverDeath_config|gpa_feverDeath_ddRecovery|gpa_feverDeath_ddRecovery_timer_task|gpa_feverDeath_cmd]> {
      - queue clear
    }
    - if <server.list_files[../].filter[ends_with[.jar]].filter[starts_with[Essentials]].is_empty> || <context.server> {
      - queue clear
    }
    - if !<player.has_permission[essentials.suicide]> {
      - queue clear
    }
    - flag <player> 'grandpartyaddons.cmd_listen.suicide'
    - narrate '<server.flag[grandpartyaddons.feverDeath.prefix.generic]><&c>/suicide <&4>is not the fun way out.' targets:<player>

    on kill|ekill command:
    - if !<server.list_scripts.parse[name].contains[gpa_feverDeath_config|gpa_feverDeath_ddRecovery|gpa_feverDeath_ddRecovery_timer_task|gpa_feverDeath_cmd]> {
      - queue clear
    }
    - if <server.list_files[../].filter[ends_with[.jar]].filter[starts_with[Essentials]].is_empty> {
      - queue clear
    }
    - if !<context.server> {
      - if !<player.has_permission[essentials.kill]> {
        - queue clear
      }
    }
    - define target '<context.args.get[1].as_player>'
    - if <def[target]||null> == 'null' {
      - queue clear
    }
    - if <def[target].has_permission[essentials.kill.exempt]> && !<player.has_permission[essentials.kill.force]> {
      - queue clear
    }
    - if <def[target].is_online> {
      - flag <def[target]> 'grandpartyaddons.cmd_listen.suicide'
      - if <def[target]> == <player> {
        - narrate '<server.flag[grandpartyaddons.feverDeath.prefix.generic]><&c>/kill <&4>is not the fun way out.'
      }
      else {
        - narrate '<server.flag[grandpartyaddons.feverDeath.prefix.generic]><&4>You were cruelly smitten by <player.name||the server>.' targets:<def[target]>
      }
    }

    on player damaged:
    - if !<server.list_scripts.parse[name].contains[gpa_feverDeath_config|gpa_feverDeath_ddRecovery|gpa_feverDeath_ddRecovery_timer_task|gpa_feverDeath_cmd]> {
      - queue clear
    }
    - define target '<context.entity.as_player>'
    - if <li@suicide|void.contains[<context.cause>]> || <player.has_flag[grandpartyaddons.cmd_listen.suicide]||false> {
      - queue clear
    }
    - if <li@1|3.contains[<def[target].gamemode.id>]> {
      - queue clear
    }
    - define dmg_inflict '<context.final_damage>'
    #Death's Door mechanics: recovery phase
    - define dd_enable '<yaml[gpa_feverdeath_config].read[deaths door.enabled].as_boolean||false>'
    - define dd_recover.enable '<yaml[gpa_feverdeath_config].read[deaths door.recovery.enabled].as_boolean||true>'
    - if <def[dd_enable]> && <def[dd_recover.enable]> && '<def[target].flag[grandpartyaddons.feverdeath.deaths door.phase]||0>' == 1 {
      - define dmg_inflict '<context.final_damage.mul[<def[target].flag[grandpartyaddons.feverdeath.deaths door.recovery_stack].mul[0.1].add[1]||1.1>]>'
    }
    - determine passively '<def[dmg_inflict]>'
    #Thanatophobia mechanics: warning
    - define t_enable '<yaml[gpa_feverdeath_config].read[thanatophobia.enabled].as_boolean||false>'
    - if <def[t_enable]> {
      - define t_percent '<yaml[gpa_feverdeath_config].read[thanatophobia.health percent].as_decimal.max[0].min[1]||0.15>'
      - define t_msgs.warn '<yaml[gpa_feverdeath_config].read[thanatophobia.messages.warning].as_list||li@&sscSomething is wrong with FeverDeath&dot>'
      - if <def[target].health.sub[<def[dmg_inflict]>]> <= 0 {
        - queue clear
      }
      - if <def[target].health.sub[<def[dmg_inflict]>].div[<def[target].health.max>]> < <def[t_percent]> && !<def[target].has_flag[grandpartyaddons.feverdeath.thanatophobia]> {
        - flag <def[target]> 'grandpartyaddons.feverdeath.thanatophobia'
        - narrate '<server.flag[grandpartyaddons.feverDeath.prefix.thanatophobia]><&c>Your health is below <def[t_percent].mul[100].round_to[1]>%! <&f><def[t_msgs.warn].get[<util.random.int[1].to[<def[t_msgs.warn].size>]>].replace[&&].with[&ss].replace[&pc].with[<&pc>].unescaped>' targets:<def[target]>
        - playsound <def[target]> sound:ENTITY_WITHER_HURT volume:0.5 pitch:0.65
      }
    }

    on player killed:
    - if !<server.list_scripts.parse[name].contains[gpa_feverDeath_config|gpa_feverDeath_ddRecovery|gpa_feverDeath_ddRecovery_timer_task|gpa_feverDeath_cmd]> {
      - queue clear
    }
    - define target '<context.entity.as_player>'
    - if <li@suicide|void.contains[<context.cause>]> || <player.has_flag[grandpartyaddons.cmd_listen.suicide]||false> {
      - queue clear
    }
    - if <li@1|3.contains[<def[target].gamemode.id>]> {
      - queue clear
    }
    - define cancelled 'false'
    #Death's Door mechanics: upon killed
    - define dd_enable '<yaml[gpa_feverdeath_config].read[deaths door.enabled].as_boolean||false>'
    - if <def[dd_enable]> {
      - define dd_death.title '<yaml[gpa_feverdeath_config].read[deaths door.death.title enabled].as_boolean||true>'
      - if '<def[target].flag[grandpartyaddons.feverdeath.deaths door.phase]||0>' != 2 {
        - determine passively '0'
        - define cancelled 'true'
        - define dd_recover.enable '<yaml[gpa_feverdeath_config].read[deaths door.recovery.enabled].as_boolean||true>'
        - define dd_death.msgs '<yaml[gpa_feverdeath_config].read[deaths door.death.messages].as_list||li@&sscSomething is wrong with FeverDeath&dot>'
        - if <def[dd_recover.enable]> && <queue.list.contains[q@gpa_feverDeath_dd_recovery_task_start_<def[target].uuid>]> {
          - run gpa_feverDeath_ddRecovery def:<player>|stop id:gpa_feverDeath_dd_recovery_task_stop_<def[target].uuid>
          - flag <def[target]> 'grandpartyaddons.feverdeath.deaths door.recovery:!'
          - if <proc[gpa_gpu_versionCheck]||5> >= 1 && <server.current_bossbars.contains[feverdeath.dd.recovery.<def[target].uuid>]> {
            - bossbar remove feverdeath.dd.recovery.<def[target].uuid>
          }
        }
        - flag <def[target]> 'grandpartyaddons.feverdeath.deaths door.phase:2'
        - adjust <def[target]> 'health:0.1'
        - playsound <def[target]> sound:ENTITY_ENDERDRAGON_AMBIENT volume:0.5 pitch:1.8
        - if <def[dd_death.title]> {
          - title 'title:<&r>' 'subtitle:<&4><&l>Death<&sq>s Door' fade_in:1t stay:2s fade_out:2s targets:<def[target]>
        }
        - narrate '<server.flag[grandpartyaddons.feverDeath.prefix.deaths door]><&c>You are at Death<&sq>s Door! <&f><def[dd_death.msgs].get[<util.random.int[1].to[<def[dd_death.msgs].size>]>].replace[&&].with[&ss].replace[&pc].with[<&pc>].unescaped>' targets:<def[target]>
      }
      else if '<def[target].flag[grandpartyaddons.feverdeath.deaths door.phase]||0>' == 2 {
        - define dd_death.kill '<yaml[gpa_feverdeath_config].read[deaths door.death.kill chance].as_decimal.max[0.01].min[1]||0.2>'
        - if <util.random.int[1].to[10000]> <= <def[dd_death.kill].mul[10000]> {
          - flag <def[target]> 'grandpartyaddons.feverdeath.deaths door.phase:0'
        }
        else {
          - determine passively '0'
          - define cancelled 'true'
          - adjust <def[target]> 'health:0.1'
          - playsound <def[target]> sound:ENTITY_ENDERDRAGON_AMBIENT volume:0.5 pitch:1.8
          - flag <def[target]> 'grandpartyaddons.feverdeath.deaths door.recovery:!'
          - if <def[dd_death.title]> {
            - title 'title:<&r>' 'subtitle:<&4><&l>Death<&sq>s Door' fade_in:1t stay:2s fade_out:2s targets:<def[target]>
          }
        }
      }
    }
    #Thanatophobia mechanics: upon getting killed
    - define t_enable '<yaml[gpa_feverdeath_config].read[thanatophobia.enabled].as_boolean||false>'
    - if <def[t_enable]> && !<context.cancelled.OR[<def[cancelled]>]> {
      - flag <def[target]> 'grandpartyaddons.feverdeath.thanatophobia:!'
    }
    #Afterlife mechanics: instant respawn
    - define al_enable '<yaml[gpa_feverdeath_config].read[afterlife.enabled].as_boolean||false>'
    - define al_instant '<yaml[gpa_feverdeath_config].read[afterlife.instant respawn].as_boolean||true>'
    - if <def[al_enable]> && <def[al_instant]> {
      - if <context.cancelled> || <def[cancelled]> {
        - queue clear
      }
      - determine passively 'cancelled'
      - define target_d_loc '<def[target].location>'
      - define xp_chance '<util.random.decimal[<def[al_exp.min]>].to[<def[al_exp.max]>]>'
      - adjust <def[target]> 'health:<def[target].health.max>'
      - adjust <def[target]> 'food_level:20'
      - adjust <def[target]> 'saturation:5'
      - adjust <def[target]> 'exhaustion:0'
      - adjust <def[target]> 'remove_effects'
      - cast SLOW <def[target]> duration:3s power:3
      - cast BLINDNESS <def[target]> duration:3s power:0
      - cast NIGHT_VISION <def[target]> duration:2s power:0
      - define al_bed '<yaml[gpa_feverdeath_config].read[afterlife.bed respawn].as_boolean||false>'
      - define s_loc '<server.flag[grandpartyaddons.gpu.essentials_spawn_location.<def[target].groups.last>]||<server.flag[grandpartyaddons.gpu.essentials_spawn_location.default]||<server.list_worlds.get[1].spawn_location.center>>>'
      - define s_loc_sc '<el@val[<def[s_loc].sub[10,20,10]>|<def[s_loc].sub[10,20,10]>].as_cuboid.spawnable_blocks.sort_by_number[distance[<def[s_loc]>]]>'
      - if <def[s_loc_sc].is_empty> {
        - define s_loc_safe '<def[s_loc]>'
      }
      else {
        - define s_loc_safe '<def[s_loc_sc].get[1]||<def[s_loc]>>'
      }
      - if <def[al_bed]> {
        - teleport <def[target]> <def[target].bed_spawn.add[0.5,0,0.5]||<def[s_loc_safe]>>
      }
      else {
        - teleport <def[target]> <def[s_loc_safe]>
      }
      - define dropped_xp '<def[target].xp.level.mul[7]>'
      - if <def[dropped_xp]> > 100 {
        - define dropped_xp '100'
      }
      - define al_exp.enable '<yaml[gpa_feverdeath_config].read[afterlife.experience handling.enable custom exp loss].as_boolean||true>'
      - define al_exp.drop '<yaml[gpa_feverdeath_config].read[afterlife.experience handling.enable player exp drop].as_boolean||true>'
      - define al_exp.min '<yaml[gpa_feverdeath_config].read[afterlife.experience handling.minimum percent lost].as_decimal.max[0].min[1]||0.25>'
      - define al_exp.max '<yaml[gpa_feverdeath_config].read[afterlife.experience handling.maximum percent lost].as_decimal.max[<def[al_exp.min]>].min[1]||0.25>'
      - define giveback_xp '0'
      - if <def[al_exp.enable]> {
        - define lost_xp '<def[target].xp.total.mul[<def[xp_chance]>]>'
        - define giveback_xp '<def[target].xp.total.sub[<def[lost_xp]>].round_down>'
        - define dropped_xp '<def[lost_xp].mul[0.25].round_down>'
        - if <def[dropped_xp]> > 300 {
          - define dropped_xp '300'
        }
      }
      - give xp qty:<def[target].xp.total.mul[-1]> to:<def[target].inventory>
      - experience set 0 player:<def[target]>
      - experience set level 0 player:<def[target]>
      - experience give <def[giveback_xp]> player:<def[target]>
      - if <def[al_exp.drop]> {
        - define leftover_xp '<def[dropped_xp]>'
        - repeat <def[dropped_xp].div[15].round_up> {
          - if <def[leftover_xp].sub[15]> >= 0 {
            - drop xp <def[target_d_loc]> qty:15
            - define leftover_xp '<def[leftover_xp].sub[15]>'
          }
          else {
            - drop xp <def[target_d_loc]> qty:<def[leftover_xp]>
            - define leftover_xp '0'
          }
        }
      }
      - define al_inv.enable '<yaml[gpa_feverdeath_config].read[afterlife.inventory handling.enable custom item loss].as_boolean||true>'
      - define al_inv.drop '<yaml[gpa_feverdeath_config].read[afterlife.inventory handling.enable player item drop].as_boolean||true>'
      - define al_inv.hotbar '<yaml[gpa_feverdeath_config].read[afterlife.inventory handling.enable tougher hotbar].as_boolean||true>'
      - define al_inv.min '<yaml[gpa_feverdeath_config].read[afterlife.inventory handling.minimum loss chance].as_decimal.max[0].min[1]||0.1>'
      - define al_inv.max '<yaml[gpa_feverdeath_config].read[afterlife.inventory handling.maximum loss chance].as_decimal.max[<def[al_inv.min]>].min[1]||0.2>'
      - define al_msg_enable '<yaml[gpa_feverdeath_config].read[afterlife.enable messages].as_boolean||true>'
      - define al_msgs '<yaml[gpa_feverdeath_config].read[afterlife.messages].as_list||li@&sscSomething is wrong with FeverDeath&dot>'
      - define player_inv '<def[target].inventory.list_contents>'
      - define inv_lost 'li@'
      - if <def[al_inv.enable]> {
        - foreach <def[target].inventory.list_contents> {
          - define inv_loss_chance '<util.random.decimal[<def[al_inv.min]>].to[<def[al_inv.max]>]>'
          - if <def[al_inv.hotbar]> && <def[loop_index]> <= 9 {
            - define inv_loss_chance '<def[inv_loss_chance].mul[0.8]>'
          }
          - if <util.random.int[1].to[10000]> <= <def[inv_loss_chance].mul[10000]> {
            - define player_inv '<def[player_inv].set[i@air].at[<def[loop_index]>]>'
            - define inv_lost '<def[inv_lost].as_list.include[<def[value]>]>'
          }
        }
        - adjust <def[target]> 'inventory_contents:<def[player_inv]>'
      }
      else {
        - define inv_lost '<def[player_inv].exclude[i@air]>'
        - adjust <def[target]> 'inventory_contents:'
      }
      - if <def[al_inv.drop]> {
        - drop <def[inv_lost].exclude[i@air]> <def[target_d_loc]>
      }
      - if <def[al_msg_enable]> {
        - narrate '<server.flag[grandpartyaddons.feverDeath.prefix.afterlife]><&f><def[al_msgs].get[<util.random.int[1].to[<def[al_msgs].size>]>].replace[&&].with[&ss].replace[&pc].with[<&pc>].unescaped>' targets:<def[target]>
      }
    }

    on player death:
    - if !<server.list_scripts.parse[name].contains[gpa_feverDeath_config|gpa_feverDeath_ddRecovery|gpa_feverDeath_ddRecovery_timer_task|gpa_feverDeath_cmd]> {
      - queue clear
    }
    - define target '<context.entity.as_player>'
    - if <li@suicide|void.contains[<context.cause>]> || <player.has_flag[grandpartyaddons.cmd_listen.suicide]||false> {
      - queue clear
    }
    - if <li@1|3.contains[<def[target].gamemode.id>]> {
      - queue clear
    }
    #Death's Door mechanics: clear flags
    - define dd_enable '<yaml[gpa_feverdeath_config].read[deaths door.enabled].as_boolean||false>'
    - define dd_recover.enable '<yaml[gpa_feverdeath_config].read[deaths door.recovery.enabled].as_boolean||true>'
    - if <def[dd_enable]> && <def[dd_recover.enable]> {
      - flag <def[target]> 'grandpartyaddons.feverDeath.deaths door.recovery:!'
      - flag <def[target]> 'grandpartyaddons.feverDeath.deaths door.phase:0'
    }
    #Afterlife mechanics: instant respawn disabled
    - define al_enable '<yaml[gpa_feverdeath_config].read[afterlife.enabled].as_boolean||false>'
    - define al_instant '<yaml[gpa_feverdeath_config].read[afterlife.instant respawn].as_boolean||true>'
    - if <def[al_enable]> && !<def[al_instant]> {
      - define dropped_xp '<def[target].xp.level.mul[7]>'
      - if <def[dropped_xp]> > 100 {
        - define dropped_xp '100'
      }
      - define al_exp.enable '<yaml[gpa_feverdeath_config].read[afterlife.experience handling.enable custom exp loss].as_boolean||true>'
      - define al_exp.drop '<yaml[gpa_feverdeath_config].read[afterlife.experience handling.enable player exp drop].as_boolean||true>'
      - if <def[al_exp.enable]> {
        - define al_exp.min '<yaml[gpa_feverdeath_config].read[afterlife.experience handling.minimum percent lost].as_decimal.max[0].min[1]||0.25>'
        - define al_exp.max '<yaml[gpa_feverdeath_config].read[afterlife.experience handling.maximum percent lost].as_decimal.max[<def[al_exp.min]>].min[1]||0.25>'
        - define lost_xp '<def[target].xp.total.mul[<util.random.decimal[<def[al_exp.min]>].to[<def[al_exp.max]>]>]>'
        - define dropped_xp '<def[lost_xp].mul[0.25].round_down>'
        - if <def[dropped_xp]> > 300 {
          - define dropped_xp '300'
        }
        - flag <def[target]> 'grandpartyaddons.feverDeath.afterlife.exp_return:<def[target].xp.total.sub[<def[lost_xp]>]>'
      }
      - if <def[al_exp.drop]> {
        - determine passively '<def[dropped_xp]>'
      }
      else {
        - determine passively 'NO_XP'
      }
      - define al_inv.enable '<yaml[gpa_feverdeath_config].read[afterlife.inventory handling.enable custom item loss].as_boolean||true>'
      - define al_inv.drop '<yaml[gpa_feverdeath_config].read[afterlife.inventory handling.enable player item drop].as_boolean||true>'
      - if <def[al_inv.enable]> {
        - define al_inv.min '<yaml[gpa_feverdeath_config].read[afterlife.inventory handling.minimum loss chance].as_decimal.max[0].min[1]||0.1>'
        - define al_inv.max '<yaml[gpa_feverdeath_config].read[afterlife.inventory handling.maximum loss chance].as_decimal.max[<def[al_inv.min]>].min[1]||0.2>'
        - define al_inv.hotbar '<yaml[gpa_feverdeath_config].read[afterlife.inventory handling.enable tougher hotbar].as_boolean||true>'
        - define player_inv '<def[target].inventory.list_contents>'
        - define inv_lost 'li@'
        - foreach <def[target].inventory.list_contents> {
          - define inv_loss_chance '<util.random.decimal[<def[al_inv.min]>].to[<def[al_inv.max]>]>'
          - if <def[al_inv.hotbar]> && <def[loop_index]> <= 9 {
            - define inv_loss_chance '<def[inv_loss_chance].mul[0.8]>'
          }
          - if <util.random.int[1].to[10000]> <= <def[inv_loss_chance].mul[10000]> {
            - define player_inv '<def[player_inv].set[i@air].at[<def[loop_index]>]>'
            - define inv_lost '<def[inv_lost].as_list.include[<def[value]>]>'
          }
        }
      }
      else {
        - define inv_lost '<def[player_inv].exclude[i@air]>'
        - foreach <def[player_inv]> {
          - define player_inv '<def[player_inv].set[i@air].at[<def[loop_index]>]>'
        }
      }
      - flag <def[target]> 'grandpartyaddons.feverDeath.afterlife.inv_return:<def[player_inv]>'
      - if <def[al_inv.drop]> {
        - determine passively '<def[inv_lost]>'
      }
      else {
        - determine passively 'NO_DROPS'
      }
    }

    on player respawns:
    - if !<server.list_scripts.parse[name].contains[gpa_feverDeath_config|gpa_feverDeath_ddRecovery|gpa_feverDeath_ddRecovery_timer_task|gpa_feverDeath_cmd]> {
      - queue clear
    }
    - if <player.has_flag[grandpartyaddons.cmd_listen.suicide]||false> {
      - flag <player> 'grandpartyaddons.cmd_listen.suicide:!'
      - queue clear
    }
    - if <li@1|3.contains[<player.gamemode.id>]> {
      - queue clear
    }
    #Afterlife mechanics: determine respawn if instant respawn is disabled
    - define al_enable '<yaml[gpa_feverdeath_config].read[afterlife.enabled].as_boolean||false>'
    - if <def[al_enable]> {
      - define al_bed '<yaml[gpa_feverdeath_config].read[afterlife.bed respawn].as_boolean||false>'
      - define al_msg_enable '<yaml[gpa_feverdeath_config].read[afterlife.enable messages].as_boolean||true>'
      - define al_msgs '<yaml[gpa_feverdeath_config].read[afterlife.messages].as_list||li@&sscSomething is wrong with FeverDeath&dot>'
      - define s_loc '<server.flag[grandpartyaddons.gpu.essentials_spawn_location.<player.groups.last>]||<server.flag[grandpartyaddons.gpu.essentials_spawn_location.default]||<server.list_worlds.get[1].spawn_location.add[0.5,0,0.5]>>>'
      - define s_loc_sc '<el@val[<def[s_loc].sub[10,20,10]>|<def[s_loc].sub[10,20,10]>].as_cuboid.spawnable_blocks.sort_by_number[distance[<def[s_loc]>]]>'
      - if <def[s_loc_sc].is_empty> {
        - define s_loc_safe '<def[s_loc]>'
      }
      else {
        - define s_loc_safe '<def[s_loc_sc].get[1]||<def[s_loc]>>'
      }
      - if <def[al_bed]> {
        - determine passively '<player.bed_spawn.add[0.5,0,0.5]||<def[s_loc_safe]>>'
      }
      else {
        - determine passively '<def[s_loc_safe]>'
      }
      - if <def[al_msg_enable]> {
        - narrate '<server.flag[grandpartyaddons.feverDeath.prefix.afterlife]><&f><def[al_msgs].get[<util.random.int[1].to[<def[al_msgs].size>]>].replace[&&].with[&ss].replace[&pc].with[<&pc>].unescaped>' targets:<player>
      }
      - if <player.has_flag[grandpartyaddons.feverDeath.afterlife.inv_return]||false> {
        - adjust <player> 'inventory_contents:<player.flag[grandpartyaddons.feverDeath.afterlife.inv_return]>'
        - flag <player> 'grandpartyaddons.feverDeath.afterlife.inv_return:!'
      }
      - if <player.has_flag[grandpartyaddons.feverDeath.afterlife.exp_return]||false> {
        - give xp qty:<player.xp.total.mul[-1]> to:<player.inventory>
        - experience set 0 player:<player>
        - experience set level 0 player:<player>
        - experience give <player.flag[grandpartyaddons.feverDeath.afterlife.exp_return].round_down> player:<player>
        - flag <player> 'grandpartyaddons.feverDeath.afterlife.exp_return:!'
      }
    }

    on player heals:
    - if !<server.list_scripts.parse[name].contains[gpa_feverDeath_config|gpa_feverDeath_ddRecovery|gpa_feverDeath_ddRecovery_timer_task|gpa_feverDeath_cmd]> {
      - queue clear
    }
    - define target '<context.entity.as_player>'
    #Death's Door mechanics: recovery
    - define dd_enable '<yaml[gpa_feverdeath_config].read[deaths door.enabled].as_boolean||false>'
    - if <def[dd_enable]> {
      - define dd_recover.enable '<yaml[gpa_feverdeath_config].read[deaths door.recovery.enabled].as_boolean||true>'
      - if '<def[target].flag[grandpartyaddons.feverdeath.deaths door.phase]||0>' == 2 {
        - if <li@SATIATED|REGEN.contains[<context.reason>]> {
          - determine '0'
        }
        - if <def[dd_recover.enable]> {
          - define dd_death.title '<yaml[gpa_feverdeath_config].read[deaths door.death.title enabled].as_boolean||true>'
          - define dd_recover.time '<yaml[gpa_feverdeath_config].read[deaths door.recovery.duration].as_decimal.max[1].min[60]||1>'
          - define dd_recover.msgs '<yaml[gpa_feverdeath_config].read[deaths door.recovery.messages].as_list||li@&sscSomething is wrong with FeverDeath&dot>'
          - if <proc[gpa_gpu_versionCheck]||5> >= 1 {
            - bossbar create feverdeath.dd.recovery.<def[target].uuid> players:<def[target]> 'title:<&c>Death<&sq>s Door Debuff Timer' progress:1 color:RED style:SOLID flags:CREATE_FOG
          }
          - flag <def[target]> 'grandpartyaddons.feverdeath.deaths door.phase:1'
          - narrate '<server.flag[grandpartyaddons.feverDeath.prefix.deaths door]><&7><def[dd_recover.msgs].get[<util.random.int[1].to[<def[dd_recover.msgs].size>]>].replace[&&].with[&ss].replace[&pc].with[<&pc>].unescaped>' targets:<def[target]>
          - flag <def[target]> 'grandpartyaddons.feverdeath.deaths door.recovery:<def[dd_recover.time]>m'
          - if <def[target].flag[grandpartyaddons.feverdeath.deaths door.recovery_stack]||0> < 6 {
            - flag <def[target]> 'grandpartyaddons.feverdeath.deaths door.recovery_stack:++'
          }
          - run gpa_feverDeath_ddRecovery 'def:<def[target]>|start|<def[target].flag[grandpartyaddons.feverdeath.deaths door.recovery]>' id:gpa_feverDeath_dd_recovery_task_start_<def[target].uuid>
          - queue clear
        }
        else {
          - flag <def[target]> 'grandpartyaddons.feverdeath.deaths door.phase:0'
        }
      }
      else if '<def[target].flag[grandpartyaddons.feverdeath.deaths door.phase]||0>' == 1 {
        - define h_limit '<def[target].health.max.mul[<def[target].flag[grandpartyaddons.feverdeath.deaths door.recovery_stack].mul[-0.15].add[1]||0.85>]>'
        - if <def[target].health.add[<context.amount>]> > <def[h_limit]> {
          - determine passively '<def[h_limit]>'
        }
        else {
          - determine passively '<context.amount.mul[<def[target].flag[grandpartyaddons.feverdeath.deaths door.recovery_stack].mul[-0.1].add[1]||0.9>]>'
        }
        - queue clear
      }
    }
    #Thanatophobia mechanics
    - define t_enable '<yaml[gpa_feverdeath_config].read[thanatophobia.enabled].as_boolean||false>'
    - if <def[t_enable]> {
      - define t_percent '<yaml[gpa_feverdeath_config].read[thanatophobia.health percent].as_decimal.max[0].min[1]||0.15>'
      - define t_msgs.recovery '<yaml[gpa_feverdeath_config].read[thanatophobia.messages.recovery].as_list||li@&sscSomething is wrong with FeverDeath&dot>'
      - if <def[target].health.add[<context.amount>].div[<def[target].health.max>]> >= <def[t_percent]> && <def[target].has_flag[grandpartyaddons.feverdeath.thanatophobia]||false> {
        - flag <def[target]> 'grandpartyaddons.feverdeath.thanatophobia:!'
        - narrate '<server.flag[grandpartyaddons.feverDeath.prefix.thanatophobia]><&f><def[t_msgs.recovery].get[<util.random.int[1].to[<def[t_msgs.recovery].size>]>].replace[&&].with[&ss].replace[&pc].with[<&pc>].unescaped>' targets:<def[target]>
      }
    }

    on player quits:
    - if !<server.list_scripts.parse[name].contains[gpa_feverDeath_config|gpa_feverDeath_ddRecovery|gpa_feverDeath_ddRecovery_timer_task|gpa_feverDeath_cmd]> {
      - queue clear
    }
    - define dd_enable '<yaml[gpa_feverdeath_config].read[deaths door.enabled].as_boolean||false>'
    - if <def[dd_enable]> {
      - define dd_recover.enable '<yaml[gpa_feverdeath_config].read[deaths door.recovery.enabled].as_boolean||true>'
      - if <def[dd_recover.enable]> {
        - if '<player.flag[grandpartyaddons.feverdeath.deaths door.phase]||0>' != 1 {
          - flag <player> 'grandpartyaddons.feverdeath.deaths door.recovery:0'
        }
        else if '<player.flag[grandpartyaddons.feverdeath.deaths door.recovery]||0>' == 1 {
          - run gpa_feverDeath_ddRecovery def:<player>|stop id:gpa_feverDeath_dd_recovery_task_stop_<player.uuid>
        }
        - queue clear
      }
    }

    on player joins:
    - if !<server.list_scripts.parse[name].contains[gpa_feverDeath_config|gpa_feverDeath_ddRecovery|gpa_feverDeath_ddRecovery_timer_task|gpa_feverDeath_cmd]> {
      - queue clear
    }
    - define dd_enable '<yaml[gpa_feverdeath_config].read[deaths door.enabled].as_boolean||false>'
    - if <def[dd_enable]> {
      - define dd_recover.enable '<yaml[gpa_feverdeath_config].read[deaths door.recovery.enabled].as_boolean||true>'
      - if <def[dd_recover.enable]> {
        - if '<player.flag[grandpartyaddons.feverdeath.deaths door.phase]||0>' != 1 {
          - flag <player> 'grandpartyaddons.feverdeath.deaths door.recovery:0'
        }
        else if '<player.flag[grandpartyaddons.feverdeath.deaths door.recovery]||0>' == 1 {
          - run gpa_feverDeath_ddRecovery def:<player>|stop id:gpa_feverDeath_dd_recovery_task_stop_<player.uuid>
        }
        - queue clear
      }
      - if '<player.flag[grandpartyaddons.feverDeath.deaths door.phase]||0>' == 1 {
        - flag <player> 'grandpartyaddons.feverDeath.deaths door.phase:0'
      }
    }