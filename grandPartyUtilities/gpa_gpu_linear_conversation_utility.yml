###############################################################################
#                                                                             #
#                  GRANDPARTYUTILITIES: LINEAR CONVERSATION                   #
#                                                                             #
###############################################################################
# 
# This script is completely independent of "gpa_gpu_main.yml". It should work
# across all versions, although the latest version of Denizen and Spigot are
# recommended for optimal performance.
# 
# 
# ----| ABOUT THIS SCRIPT
# 
# This script carries out a linear conversation much like a standard RPG
# dialogue sequence. There is no choices available. Automatic formatting is not
# supported.
# 
# 
# ----| HOW TO USE
# 
# To run this script, run this command:
#   - run gpa_gpu_linear_conversation_utility player:<dPlayer> def:<conversation_name>|<step_name>|<true/false>
# 
# "<conversation_name>" should be the name of a loaded conversation.
# "<step>" should be the number of the step that the script should start at.
# "<true/false>" (optional) determines if the script should assign a custom
# queue ID to each new line of conversation with this format:
#   - gpa_gpu_linear_conversation_utility_conversation_<dPlayer UUID>_c_<conversation_name>_step_<#>
# WARNING: If you set the third definition to "true", you MUST make sure that
# you are not attempting to run another queue with the exact same ID!
# 
# To use this script out-of-the-box, there is a /gpulcu command. It requires
# the player A) have OP, B) have the permission "gpu.lcu", or C) have the flag
# "gpa.gpu.lcu".
# 
# To add conversations, create a new YAML file in the folder "/plugins/
# GrandPartyUtilities/linear_conversations/". Any conversations will be loaded
# into the server when scripts are reloaded OR when the server starts. An
# example conversation will be automatically created.
# 
# 
# When a conversation is run, you can use these tags:
# - <player.flag[gpa.gpu.lcu.<name>.step]>
# - <player.flag[gpa.gpu.lcu.<name>.queue]>
# 
# "gpa.gpu.lcu.<name>.step" returns the conversation step, if any.
# "gpa.gpu.lcu.<name>.queue" returns the step queue, if the third definition is
#                            set to false.
# 
# For a list of valid placeholders, look at the generated "example_
# conversation.yml" file.
# 
# 
# ----| CAVEATS
# 
# Even though this script supports 1.8.8 to 1.12, it requires the latest
# developmental version of Denizen.
# 
# The third definition in the run command is EXTREMELY dangerous! Do not use
# it unless you know what you're doing!
# 
# If any player uses the /gpulcu command, absolutely do NOT use scripts to
# independently create queues with IDs of the format:
#   - gpa_gpu_linear_conversation_utility_conversation_<dPlayer UUID>_c_<conversation_name>_step_<#>
# 
# 

gpa_gpu_linear_conversation_utility:
  type: task
  debug: false
  speed: 0
  definitions: name|step|use_id
  script:
  - if <player||null> == null {
    - announce to_console '<&c>Error! A dPlayer object is required via the <&dq>player<&dq> argument!' format:gpa_gpu_linear_conversation_utility_format
    - queue clear
  }
  - define flag 'gpa.gpu.lcu.<def[name]>'
  - flag player '<def[flag]>:!'
  - define null 'null-<util.random.uuid>'
  - if <server.flag[gpa.gpu.lcu.invalid].as_list.include[<def[null]>].contains[<def[name]||<def[null]>>]||false> {
    - announce to_console '<&c>Error! Conversation <&dq><def[name]||null><&dq> is invalid, has a duplicate, or doesn<&sq>t exist!' format:gpa_gpu_linear_conversation_utility_format
    - queue clear
  }
  - define y_id '<server.flag[gpa.gpu.lcu.list].as_list.map_get[<def[name]||<def[null]>>]||<def[null]>>'
  - if !<yaml.list.contains[<def[y_id]>]> {
    - announce to_console '<&c>Error! The YAML configuration for <&dq><def[name]||null><&dq> is invalid or does not exist!' format:gpa_gpu_linear_conversation_utility_format
    - queue clear
  }
  - if !<yaml[<def[y_id]>].list_keys[<def[name]>].filter[matches[\d+]].contains[<def[step]||null>]> {
    - queue clear
  }
  - define text '<yaml[<def[y_id]>].read[<def[name]>.<def[step]>.text].unescaped.parse_color[%]>'
  - define ntext 'li@'
  #- foreach <def[text].replace[\\u[a-zA-Z0-9]{4}\\].with[|%0|].split[|]> {
  #  - if <def[value].matches[\\u[a-zA-Z0-9]{4}\\]> {
  #    - define ntext '<def[ntext].include[<&chr[<def[value].after[\u].before[\]>]>]>'
  #    - foreach next
  #  }
  #  - define ntext '<def[ntext].include[<def[value]>]>'
  #}
  #- define text '<def[ntext].separated_by[]>'
  - define replacelist 'li@'
  #- foreach <s@gpa_gpu_linear_conversation_utility.yaml_key[placeholders]> {
  #  - define term '<def[value].after[/]>'
  #  - if !<def[term].matches[\{[A-Z_]+\((.*)\)\}]> {
  #    - define replacelist '<def[replacelist].include[replace[<def[value].before[/]>].with[<%term%>]]'
  #    - foreach next
  #  }
  #  - define replacelist '<def[replacelist].include[replace[<def[value].before[/]>].with[<%term%>]]'
  #}
  #- define replacelist '<def[replacelist].separated_by[.]>'
  #- narrate '<def[ntext].separated_by[].%replacelist%>'
  - define spl_list '<s@gpa_gpu_linear_conversation_utility.yaml_key[static_placeholders]>'
  - define dpl_list '<s@gpa_gpu_linear_conversation_utility.yaml_key[dynamic_placeholders]>'
  - define ntext 'li@'
  - foreach '<def[text].replace[regex:\{[^\}]+\}].with[|$0|].split[|]>' {
    - define tag:!
    - define replace:!
    - define textpiece '<def[value]>'
    - if <def[spl_list].get_sub_items[1].contains[<def[textpiece]>]> {
      - define tag '<def[spl_list].map_get[<def[textpiece]>]>'
      - define ntext '<def[ntext].include[<parse:%tag%>]>'
      #- narrate '<def[tag]>'
      - foreach next
    }
    - foreach <def[dpl_list]> {
      - define dpl_reg '<def[value].before[/]>'
      - if <def[dpl_reg]> == '\{PLACEHOLDER\[([a-zA-Z0-9_]+)\]\}' && !<server.list_plugins.contains[pl@Depenizen|pl@PlaceholderAPI]> {
        - foreach next
      }
      - if <def[textpiece].matches[<def[dpl_reg]>]> {
        - define tag '<def[textpiece].replace[regex:<def[dpl_reg]>].with[$1]>'
        - define rtag '<def[value].after[/]>'
        - define ntext '<def[ntext].include[<parse:%rtag%>]>'
        - define replace 'true'
        - foreach next
      }
    }
    - if <def[replace]||false> {
      - foreach next
    }
    - define ntext '<def[ntext].include[<def[textpiece]>]>'
  }
  - define text '<def[ntext].separated_by[]>'
  - narrate '<def[text]>'
  # action
  - if <yaml[<def[y_id]>].list_keys[<def[name]>.<def[step]>].contains[run_script]> {
    - define rscrpt '<yaml[<def[y_id]>].read[<def[name]>.<def[step]>.run_script]>'
    - if <server.list_scripts.parse[name].contains[<def[rscrpt]>]> {
      - run <def[rscrpt]> instantly player:<player> def:<def[name]>|<def[step]>
    }
  }
  ###################
  - if !<yaml[<def[y_id]>].read[<def[name]>.<def[step]>.delay].matches[\d+\.*\d*]||false>
    || !<yaml[<def[y_id]>].list_keys[<def[name]>].contains[<def[step].add_int[1]>]> {
    - queue clear
  }
  - flag player '<def[flag]>.step:<def[step]>'
  - wait <yaml[<def[y_id]>].read[<def[name]>.<def[step]>.delay]>s
  - define step '<player.flag[<def[flag]>.step]>'
  - if <def[use_id]||false> {
    - run gpa_gpu_linear_conversation_utility 'player:<player>' 'def:<def[name]>|<def[step].add_int[1]>|true'
      id:<def[id_prefix]><def[name]>_step_<def[step].add_int[1]>
  }
  else {
    - run gpa_gpu_linear_conversation_utility 'player:<player>' 'def:<def[name]>|<def[step].add_int[1]>'
    - flag player '<def[flag]>.queue:<queue>'
  }
  static_placeholders:
  - '{PLAYER_NAME}/<player.name>'
  - '{PLAYER_PING}/<player.ping>'
  - '{PLAYER_XP}/<player.exp.total>'
  - '{PLAYER_XP_PERCENT}/<player.exp>'
  - '{PLAYER_XP_LEVEL}/<player.exp.level>'
  - '{PLAYER_XP_TO_NEXT_LEVEL}/<player.exp.to_next_level>'
  - '{PLAYER_HEALTH}/<player.health.round_to[2]>'
  - '{PLAYER_HEALTH_PERCENT}/<player.health.percentage.round_to[1]>'
  dynamic_placeholders:
  - '\{PLACEHOLDER\[([a-zA-Z0-9_]+)\]\}/<placeholder[<def[tag]>]>'
  - '\{PLAYER_FLAG\[(.+)\]\}/<player.flag[<def[tag]>]>'
  - '\{SERVER_FLAG\[(.+)\]\}/<server.flag[<def[tag]>]>'
  - '\{u([a-zA-Z0-9]{4})\}/<&chr[<def[tag]>]>'

gpa_gpu_linear_conversation_utility_cmd:
  type: command
  debug: false
  name: gpulcu
  description: 'Uses the GrandPartyUtilities Linear Conversation Tool.'
  usage: /gpulcu <&lt>help|reload|run<&gt> (conversation) (step) (player)
  allowed help:
  - determine <context.server.or[<player.is_op||false>].or[<player.has_permission[gpu.lcu]||false>].or[<player.has_flag[gpa.gpu.lcu]||false>]>
  tab complete:
  - if !<context.server.or[<player.is_op||false>].or[<player.has_permission[gpu.lcu]||false>].or[<player.has_flag[gpa.gpu.lcu]||false>]> {
    - queue clear
  }
  - define s '<context.raw_args.to_list.count[ ]>'
  - if <def[s]> == 0 {
    - determine <li@help|reload|run.filter[starts_with[<context.args.get[1]||>]]>
  }
  else if <def[s]> == 1 && <context.args.get[1]||> == 'run' {
    - determine <server.flag[gpa.gpu.lcu.list].as_list.get_sub_items[1].exclude[<server.flag[gpa.gpu.lcu.invalid].as_list||li@>].filter[starts_with[<context.args.get[2]||>]]>
  }
  else if <def[s]> == 3 && <context.args.get[1]||> == 'run' {
    - determine <server.list_online_players.parse[name].filter[starts_with[<context.args.get[4]||>]]>
  }
  script:
  - if !<context.server.or[<player.is_op||false>].or[<player.has_permission[gpu.lcu]||false>].or[<player.has_flag[]||false>]> {
    - queue clear
  }
  - choose <context.args.get[1]||null>:
    - case reload:
      - narrate '<&a>Attempting to reload GPU LCU conversations. Check console for any errors.' format:gpa_gpu_linear_conversation_utility_format
      - run gpa_gpu_linear_conversation_utility_yaml_loader path:load_conversations instantly
    - case run:
      - define name '<context.args.get[2]||null>'
      - define step '<context.args.get[3]||null>'
      - if !<server.flag[gpa.gpu.lcu.list].as_list.get_sub_items[1].contains[<def[name]>]> {
        - narrate '<&c>Conversation <&dq><def[name]><&dq> does not exist!' format:gpa_gpu_linear_conversation_utility_format
        - queue clear
      }
      - if !<def[step].matches[\d+]> {
        - define step '1'
      }
      - if <context.server> && !<server.list_online_players.parse[name].contains[<context.args.get[4]||>]> {
        - narrate '<&c>Invalid player! The player must be online!' format:gpa_gpu_linear_conversation_utility_format
      }
      - narrate '<&f>Attempting to run a conversation <&dq><def[name]><&dq> at step <def[step]> for <context.args.get[4]||<player.name>>.
        Check console for any errors.' format:gpa_gpu_linear_conversation_utility_format
      - define qid 'gpa_gpu_linear_conversation_utility_conversation_<player.uuid.replace[-].with[_]>_c_<def[name]>_step_<def[step]>'
      - if <queue.list.contains[q@<def[qid]>]> {
        - queue q@<def[qid]> clear
      }
      - run gpa_gpu_linear_conversation_utility player:<context.args.get[4]||<player>> def:<def[name]>|<def[step]>
    - default:
      - narrate '<&f>GrandPartyUtilities Linear Conversation Tool Help<&co>'
      - narrate '<&7>/gpulcu help || <&8>Displays this help page.'
      - narrate '<&7>/gpulcu reload || <&8>Reloads conversations from file. Performs a recursive check for all YAML files in the folder "/plugins/GrandPartyUtilities/linear_conversations/"'
      - narrate '<&7>/gpulcu run <&lt>conversation<&gt> (step) (player) || <&8>Runs a conversation, with an optional step argument for the specific step to use and an optional player argument. If the command is run by CONSOLE, the step and player arguments are mandatory.'

gpa_gpu_linear_conversation_utility_yaml_loader:
  type: world
  debug: false
  events:
    on server start:
    - run locally 'load_conversations' instantly
  
  load_conversations:
  - foreach <yaml.list.filter[starts_with[gpa_gpu_linear_conversation_data_]]> {
    - yaml unload id:<def[value]>
  }
  - flag server 'gpa.gpu.lcu:!'
  - define start_file '../GrandPartyUtilities/linear_conversations/'
  - run locally 'validate' instantly 'def:<def[start_file]>'

  validate:
  - if !<def[1].ends_with[/]> {
    - define 1 '<def[1]>/'
  }
  - define fs '<server.list_files[<def[1]>]||li@>'
  - if <def[fs].is_empty> {
    - announce to_console '<&c>Warning! There are no loaded conversations! We will wait for 10 seconds for
      the example template to fully load.' format:gpa_gpu_linear_conversation_utility_format
    - log '' type:clear file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '# ----| VALID PLACEHOLDERS' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '# {PLAYER_NAME}' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '#   Returns the player<&sq>s username.' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '# {PLAYER_PING}' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '#   Returns the player<&sq>s ping.' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '# {PLAYER_XP}' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '#   Returns the player<&sq>s total XP.' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '# {PLAYER_XP_PERCENT}' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '#   Returns how much XP the player has in a level, as a percent.' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '# {PLAYER_XP_LEVEL}' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '#   Returns the player<&sq>s XP level.' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '# {PLAYER_XP_TO_NEXT_LEVEL}' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '#   Returns how much XP the player needs to level up.' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '# {PLAYER_HEALTH}' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '#   Returns the player<&sq>s health.' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '# {PLAYER_HEALTH_PERCENT}' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '#   Returns the player<&sq>s health as a percent.' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '# {PLACEHOLDER[<&lt>PAPI tag<&gt>]}' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '#   Returns any valid PlaceholderAPI placeholder. Replace <&lt>PAPI tag<&gt> with a' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '#   valid PlaceholderAPI tag, without the percent marks. For example,' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '#   <&dq>{PLACEHOLDER[player_exp]}<&dq>' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '# {PLAYER_FLAG[<&lt>Denizen flag<&gt>]}' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '#   Returns the value of the Denizen flag on the player, if any.' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '# {SERVER_FLAG[<&lt>Denizen flag<&gt>]}' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '#   Returns the value of the Denizen flag on the server, if any.' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '# {uUNICODE_ENCODING}' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '#   Returns a Unicode character with the specific 4-character encoding. For' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '#   example, {u2665} returns a heart.' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '# ' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '# ' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log 'example_conversation:' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '    1:' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        text: <&sq>[Server] This is an example conversation.<&sq>' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        delay: 2' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '    2:' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        text: <&sq>[Server] You will be required to understand that you need to escape relevant special characters, such as single quotes (&sq), double quotes (&quo), and colons (&co).<&sq>' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        delay: 2' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '    3:' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        text: <&sq>[Server] A missing step will cause the conversation to stop with no errors, because the utility will assume you wanted to end there but added in a delay key for no reason.<&sq>' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        delay: 2' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '    4:' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        text: <&sq>[Server] You can use color codes by replacing & with <&pc>. For example, <&pc>agreen<&pc>r!<&sq>' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        delay: 2' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '    5:' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        text: <&sq>[Server] If you want to use special Unicode characters, use &quo{uUNICODE_ENCODING}&quo. For example, a heart would be {u2665}.<&sq>' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        delay: 2' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '    6:' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        text: <&sq>[Server] A list of valid placeholders can be found in the example_conversation file.<&sq>' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        delay: 2' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '    7:' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        text: <&sq>[Server] You can also choose to run a script using the &quorun_script&quo key. The specified script must be valid and loaded into the server.<&sq>' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        delay: 2' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '    8:' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        text: <&sq>[Server] To end a conversation, simply put no delay key.<&sq>' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - wait 10s
    - announce to_console '<&c>Assuming the file has loaded. Commencing conversation reading.' format:gpa_gpu_linear_conversation_utility_format
  }
  - run locally 'file_search' instantly 'def:<def[1]>|true'

  file_search:
  - if !<def[1].ends_with[/]> {
    - define 1 '<def[1]>/'
  }
  - define fl 'li@'
  - define fs '<server.list_files[<def[1]>]||li@>'
  - foreach <def[fs]> {
    - if <def[value].matches[.+\.yml]> {
      - define fl '<def[fl].include[<def[1]><def[value]>]>'
      - foreach next
    }
    else if <def[value].matches[.+\..+]> {
      - foreach next
    }
    - ~run locally 'file_search' instantly 'def:<def[1]><def[value]>|false'
  }
  - flag server 'gpa.gpu.lcu.prepare:|:<def[fl]>'
  - if !<def[2]||false> {
    - queue clear
  }
  - foreach <server.flag[gpa.gpu.lcu.prepare].as_list.deduplicate> {
    - define y_id 'gpa_gpu_linear_conversation_data_<util.random.uuid.replace[-].with[_]>'
    - yaml create id:<def[y_id]>
    - yaml load:<def[value]> id:<def[y_id]>
    - if !<yaml.list.contains[<def[y_id]>]> {
      - announce to_console '<&c>Error! A YAML file is considered unusable! The file
        <&dq>/<def[value].after[GrandPartyUtilities/linear_conversations/]> is most likely empty.<&dq>'
        format:gpa_gpu_linear_conversation_utility_format
      - foreach next
    }
  }
  - flag server 'gpa.gpu.lcu.prepare:!'
  - define ylist 'li@'
  - foreach <yaml.list.filter[starts_with[gpa_gpu_linear_conversation_data_]]> {
    - define y_id '<def[value]>'
    - foreach <yaml[<def[y_id]>].list_keys[]> {
      - define ylist '<def[ylist].include[<def[value]>/<def[y_id]>]>'
    }
  }
  - define ylisterror 'li@'
  - foreach <def[ylist].get_sub_items[1]> {
    - if <def[ylist_c_<def[value]>].exists> {
      - define ylisterror '<def[ylisterror].include[<def[value]>]>'
      - foreach next
    }
    - define ylist_c_<def[value]> '1'
  }
  - flag server 'gpa.gpu.lcu.list:|:<def[ylist]>'
  - flag server 'gpa.gpu.lcu.invalid:|:<def[ylisterror].deduplicate>'
  - if !<def[ylisterror].is_empty> {
    - announce to_console '<&c>Error! There are multiple conversations with the same name!
      The following conversation name(s) are suspect<&co>' format:gpa_gpu_linear_conversation_utility_format
    - announce to_console '<&4><server.flag[gpa.gpu.lcu.invalid].as_list.formatted>'
  }
  - announce to_console '<&a>Loaded conversation(s).' format:gpa_gpu_linear_conversation_utility_format

gpa_gpu_linear_conversation_utility_format:
  type: format
  debug: false
  format: '[<&a>GPU<&r> <&2>LCU<&r>] <text>'