###############################################################################
#                                                                             #
#                  GRANDPARTYUTILITIES: LINEAR CONVERSATION                   #
#                                                                             #
###############################################################################
# 
# This script is completely independent of "gpa_gpu_main.yml". It should work
# across all versions, although the latest version of Denizen and Spigot are
# recommended for optimal performance.
# 
# 
# ----| ABOUT THIS SCRIPT
# 
# This script carries out a linear conversation much like a standard RPG
# dialogue sequence. There is no choices available. Automatic formatting is not
# supported.
# 
# 
# ----| HOW TO USE
# 
# To run this script, run this command:
#   - run gpa_gpu_linear_conversation_utility player:<dPlayer> def:<conversation_name>|<step_name>|<true/false>
# 
# "<conversation_name>" should be the name of a loaded conversation.
# "<step>" should be the number of the step that the script should start at.
# "<true/false>" (optional) determines if the script should assign a custom
# queue ID to each new line of conversation with this format:
#   - gpa_gpu_linear_conversation_utility_conversation_<dPlayer UUID>_c_<conversation_name>_step_<#>
# WARNING: If you set the third definition to "true", you MUST make sure that
# you are not attempting to run another queue with the exact same ID!
# 
# To use this script out-of-the-box, there is a /gpulcu command. It requires
# the player A) have OP, B) have the permission "gpu.lcu", or C) have the flag
# "gpa.gpu.lcu".
# 
# To add conversations, create a new YAML file in the folder "/plugins/
# GrandPartyUtilities/linear_conversations/". Any conversations will be loaded
# into the server when scripts are reloaded OR when the server starts. An
# example conversation will be automatically created.
# 
# 
# When a conversation is run, you can use these tags:
# - <player.flag[gpa.gpu.lcu.<name>.step]>
# - <player.flag[gpa.gpu.lcu.<name>.queue]>
# 
# "gpa.gpu.lcu.<name>.step" returns the conversation step, if any.
# "gpa.gpu.lcu.<name>.queue" returns the step queue, if the third definition is
#                            set to false.
# 
# For a list of valid placeholders, look at the generated "example_
# conversation.yml" file.
# 
# When using a "run_script" key, note that the conversation name and step the
# player is on are immediately passed to the specified script as definitions.
# You can use <def[1]> and <def[2]> to return the respective values, or any
# relevant definition name as specified by a "definitions:" key in the task
# script.
# The player is also attached to the task script run, so any player-related
# tag should work as well.
# 
# 
# ----| COMMANDS & PERMISSIONS
# 
# /gpulcu reload
#   Reloads conversations from ./plugins/GrandPartyUtilities/linear_conversations/
# 
# /gpulcu run <conversation_name> (step) (player_name)
#   Runs a conversation at the optionally defined step (or step 1) and to the
#   optionally defined player (or the player who ran the command).
# 
# Permission "gpu.lcu", flag "gpa.gpu.lcu.permission", or OP status are required to run
# the commands.
# 
# 
# ----| CAVEATS
# 
# Even though this script supports 1.8.8 to 1.12, it requires the latest
# developmental version of Denizen.
# 
# The third definition in the run command is EXTREMELY dangerous! Do not use
# it unless you know what you're doing!
# 
# If any player uses the /gpulcu command, absolutely do NOT use scripts to
# independently create queues with IDs of the format:
#   - gpa_gpu_linear_conversation_utility_conversation_<dPlayer UUID>_c_<conversation_name>_step_<#>
# 
# 

gpa_gpu_linear_conversation_utility:
  type: task
  debug: false
  speed: 0
  definitions: name|step|use_id
  script:
  # Run quick checks on valid player, valid conversation name, and valid YAML
  - if <player||null> == null {
    - announce to_console '<&c>Error! A dPlayer object is required via the <&dq>player<&dq> argument!' format:gpa_gpu_linear_conversation_utility_format
    - queue clear
  }
  - define name '<def[name]||null>'
  - define flag 'gpa.gpu.lcu.<def[name]>'
  - if <server.flag[gpa.gpu.lcu.invalid].as_list.include[null].contains[<def[name]||null>]||false> {
    - announce to_console '<&c>Error! Conversation <&dq><def[name]||null><&dq> is invalid, has a duplicate, or doesn<&sq>t exist!' format:gpa_gpu_linear_conversation_utility_format
    - queue clear
  }
  - define y_id '<server.flag[gpa.gpu.lcu.list].as_list.map_get[<def[name]||<def[null]>>]||<def[null]>>'
  - if !<yaml.list.contains[<def[y_id]>]> {
    - announce to_console '<&c>Error! The YAML configuration for <&dq><def[name]||null><&dq> is invalid or does not exist!' format:gpa_gpu_linear_conversation_utility_format
    - queue clear
  }

  # Clear player's flags related to this conversation
  - flag player '<def[flag]>:!'

  # If the step is not a valid positive integer, assume the step number is 1.
  - define step '<def[step].max[1].round_down||1>'

  # Define a special null case to avoid conflicts with users who think it's
  # funny to make a text line "null"
  - define null 'null-<util.random.uuid>'

  # Check to see if a text key has a valid entry
  - if <yaml[<def[y_id]>].read[<def[name]>.<def[step]>.text]||<def[null]>> == <def[null]> {
    - queue clear
  }

  # Parse and narrate text
  - define text '<parse:<yaml[<def[y_id]>].read[<def[name]>.<def[step]>.text]>>'
  - narrate '<def[text].replace[\n].with[<&nl>].unescaped.parse_color[%]>'

  # Check to see if we should flag the player with the queue ID or not (based
  # on if the third definition is defined as "true"
  - if !<def[use_id]||false> {
    - flag player '<def[flag]>.queue:<queue>'
  }

  # Check to see if there is a valid run_script
  - if <yaml[<def[y_id]>].read[<def[name]>.<def[step]>.run_script]||<def[null]>> != <def[null]> {
    - define rscrpt '<yaml[<def[y_id]>].read[<def[name]>.<def[step]>.run_script]>'
    - if <server.list_scripts.parse[name].contains[<def[rscrpt]>]> {
      - run <def[rscrpt]> instantly player:<player> def:<def[name]>|<def[step]>
    }
  }

  # Check to see if a next step exists or if a delay key is missing
  - if !<yaml[<def[y_id]>].read[<def[name]>.<def[step]>.delay].matches[\d+\.*\d*]||false>
    || !<yaml[<def[y_id]>].contains[<def[name]>.<def[step].add_int[1]>]> {
    - queue clear
  }

  - flag player '<def[flag]>.step:<def[step]>'
  - wait <yaml[<def[y_id]>].read[<def[name]>.<def[step]>.delay]>s

  # Check to see if the third definition is used. If so, proceed with using a
  # custom queue ID. Else, flag the player with the next queue.
  - if <def[use_id]||false> {
    - define id_prefix 'gpa_gpu_linear_conversation_utility_conversation_<player.uuid>_c_'
    - run gpa_gpu_linear_conversation_utility 'player:<player>' 'def:<def[name]>|<def[step].add_int[1]>|true'
      id:<def[id_prefix]><def[name]>_step_<def[step].add_int[1]>
  }
  else {
    - run gpa_gpu_linear_conversation_utility 'player:<player>' 'def:<def[name]>|<def[step].add_int[1]>'
  }

gpa_gpu_linear_conversation_utility_cmd:
  type: command
  debug: false
  name: gpulcu
  description: 'Uses the GrandPartyUtilities Linear Conversation Tool.'
  usage: /gpulcu <&lt>help|reload|run<&gt> (conversation) (step) (player)
  allowed help:
  - determine <context.server.or[<player.is_op||false>].or[<player.has_permission[gpu.lcu]||false>].or[<player.has_flag[gpa.gpu.lcu.permission]||false>]>
  tab complete:
  - if !<context.server.or[<player.is_op||false>].or[<player.has_permission[gpu.lcu]||false>].or[<player.has_flag[gpa.gpu.lcu.permission]||false>]> {
    - queue clear
  }
  - define s '<context.raw_args.to_list.count[ ]>'
  - if <def[s]> == 0 {
    - determine <li@help|reload|run.filter[starts_with[<context.args.get[1]||>]]>
  }
  else if <def[s]> == 1 && <context.args.get[1]||> == 'run' {
    - determine <server.flag[gpa.gpu.lcu.list].as_list.get_sub_items[1].exclude[<server.flag[gpa.gpu.lcu.invalid].as_list||li@>].filter[starts_with[<context.args.get[2]||>]]>
  }
  else if <def[s]> == 3 && <context.args.get[1]||> == 'run' {
    - determine <server.list_online_players.parse[name].filter[starts_with[<context.args.get[4]||>]]>
  }
  script:
  - if !<context.server.or[<player.is_op||false>].or[<player.has_permission[gpu.lcu]||false>].or[<player.has_flag[]||false>]> {
    - queue clear
  }
  - choose <context.args.get[1]||null>:
    - case reload:
      - narrate '<&a>Attempting to reload GPU LCU conversations. Check console for any errors.' format:gpa_gpu_linear_conversation_utility_format
      - run gpa_gpu_linear_conversation_utility_yaml_loader path:load_conversations instantly
    - case run:
      - define name '<context.args.get[2]||null>'
      - define step '<context.args.get[3]||null>'
      - if !<server.flag[gpa.gpu.lcu.list].as_list.get_sub_items[1].contains[<def[name]>]> {
        - narrate '<&c>Conversation <&dq><def[name]><&dq> does not exist!' format:gpa_gpu_linear_conversation_utility_format
        - queue clear
      }
      - if !<def[step].matches[\d+]> {
        - define step '1'
      }
      - if <context.server> && !<server.list_online_players.parse[name].contains[<context.args.get[4]||>]> {
        - narrate '<&c>Invalid player! The player must be online!' format:gpa_gpu_linear_conversation_utility_format
      }
      - narrate '<&f>Attempting to run a conversation <&dq><def[name]><&dq> at step <def[step]> for <context.args.get[4]||<player.name>>.
        Check console for any errors.' format:gpa_gpu_linear_conversation_utility_format
      - define qid 'gpa_gpu_linear_conversation_utility_conversation_<player.uuid.replace[-].with[_]>_c_<def[name]>_step_<def[step]>'
      - if <queue.list.contains[q@<def[qid]>]> {
        - queue q@<def[qid]> clear
      }
      - run gpa_gpu_linear_conversation_utility player:<context.args.get[4]||<player>> def:<def[name]>|<def[step]>
    - default:
      - narrate '<&f>GrandPartyUtilities Linear Conversation Tool Help<&co>'
      - narrate '<&7>/gpulcu help || <&8>Displays this help page.'
      - narrate '<&7>/gpulcu reload || <&8>Reloads conversations from file. Performs a recursive check for all YAML files in the folder "/plugins/GrandPartyUtilities/linear_conversations/"'
      - narrate '<&7>/gpulcu run <&lt>conversation<&gt> (step) (player) || <&8>Runs a conversation, with an optional step argument for the specific step to use and an optional player argument. If the command is run by CONSOLE, the step and player arguments are mandatory.'

gpa_gpu_linear_conversation_utility_yaml_loader:
  type: world
  debug: false
  events:
    on server start:
    - run locally 'load_conversations' instantly

  # Begin loading of conversations
  load_conversations:
  - foreach <yaml.list.filter[starts_with[gpa_gpu_linear_conversation_data_]]> {
    - yaml unload id:<def[value]>
  }
  - flag server 'gpa.gpu.lcu:!'
  - define start_file '../GrandPartyUtilities/linear_conversations/'
  - run locally 'validate' instantly 'def:<def[start_file]>'

  # Verify if there is a loaded conversation. If not, create the example conversation.
  validate:
  - if !<def[1].ends_with[/]> {
    - define 1 '<def[1]>/'
  }
  - define fs '<server.list_files[<def[1]>]||li@>'
  - if <def[fs].is_empty> {
    - announce to_console '<&c>Warning! There are no loaded conversations! We will wait for 10 seconds for
      the example template to fully load.' format:gpa_gpu_linear_conversation_utility_format
    - log '' type:clear file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '# ' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '# WARNING: When using Denizen tags, please be careful!' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '# ' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '# ' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log 'example_conversation:' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '    1:' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        text: <&sq>[Server] This is an example conversation.<&sq>' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        delay: 2' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '    2:' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        text: <&sq>[Server] You will be required to understand that you need to escape relevant special characters, such as single quotes (&sq), double quotes (&quo), and colons (&co).<&sq>' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        delay: 2' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '    3:' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        text: <&sq>[Server] A missing step will cause the conversation to stop with no errors, because the utility will assume you wanted to end there but added in a delay key for no reason.<&sq>' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        delay: 2' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '    4:' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        text: <&sq>[Server] You can use color codes by replacing & with <&pc>. For example, <&pc>agreen<&pc>r! You can also\nsplit lines!<&sq>' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        delay: 2' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '    5:' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        text: <&sq>[Server] You can use any valid, relevant Denizen tags. For example, you can use the &lt&chr[UNICODE_ENCODING]&gt tag to return a Unicode character (for example, a heart would be <&lt>&chr[2665]<&gt>).<&sq>' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        delay: 2' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '    6:' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        text: <&sq>[Server] When using tags, remember that only the player is attached.<&sq>' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        delay: 2' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '    7:' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        text: <&sq>[Server] You can also choose to run a script using the &quorun_script&quo key. The specified script must be valid and loaded into the server.<&sq>' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        delay: 2' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '    8:' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - log '        text: <&sq>[Server] To end a conversation, simply put no delay key.<&sq>' type:none file:<def[1].replace[firstregex:\.\./].with[plugins/]>example_conversation.yml
    - wait 10s
    - announce to_console '<&c>Assuming the file has loaded. Commencing conversation reading.' format:gpa_gpu_linear_conversation_utility_format
  }
  - run locally 'file_search' instantly 'def:<def[1]>|true'

  # Begin a recursive file search. This can create a lot of lag, so users are
  # advised to limit the number of folders and files as much as possible.
  file_search:
  - if !<def[1].ends_with[/]> {
    - define 1 '<def[1]>/'
  }
  - define fl 'li@'
  - define fs '<server.list_files[<def[1]>]||li@>'
  - foreach <def[fs]> {
    - if <def[value].matches[.+\.yml]> {
      - define fl '<def[fl].include[<def[1]><def[value]>]>'
      - foreach next
    }
    else if <def[value].matches[.+\..+]> {
      - foreach next
    }
    - ~run locally 'file_search' instantly 'def:<def[1]><def[value]>|false'
  }
  - flag server 'gpa.gpu.lcu.prepare:|:<def[fl]>'
  - if !<def[2]||false> {
    - queue clear
  }
  - foreach <server.flag[gpa.gpu.lcu.prepare].as_list.deduplicate> {
    - define y_id 'gpa_gpu_linear_conversation_data_<util.random.uuid.replace[-].with[_]>'
    - yaml create id:<def[y_id]>
    - yaml load:<def[value]> id:<def[y_id]>
    - if !<yaml.list.contains[<def[y_id]>]> {
      - announce to_console '<&c>Error! A YAML file is considered unusable! The file
        <&dq>/<def[value].after[GrandPartyUtilities/linear_conversations/]><&dq> is most likely empty.'
        format:gpa_gpu_linear_conversation_utility_format
      - foreach next
    }
  }
  - flag server 'gpa.gpu.lcu.prepare:!'
  - define ylist 'li@'
  - foreach <yaml.list.filter[starts_with[gpa_gpu_linear_conversation_data_]]> {
    - define y_id '<def[value]>'
    - foreach <yaml[<def[y_id]>].list_keys[]> {
      - define ylist '<def[ylist].include[<def[value]>/<def[y_id]>]>'
    }
  }
  - define ylisterror 'li@'
  - foreach <def[ylist].get_sub_items[1]> {
    - if <def[ylist_c_<def[value]>].exists> {
      - define ylisterror '<def[ylisterror].include[<def[value]>]>'
      - foreach next
    }
    - define ylist_c_<def[value]> '1'
  }
  - flag server 'gpa.gpu.lcu.list:|:<def[ylist]>'
  - flag server 'gpa.gpu.lcu.invalid:|:<def[ylisterror].deduplicate>'
  - if !<def[ylisterror].is_empty> {
    - announce to_console '<&c>Error! There are multiple conversations with the same name!
      The following conversation name(s) are suspect<&co>' format:gpa_gpu_linear_conversation_utility_format
    - announce to_console '<&4><server.flag[gpa.gpu.lcu.invalid].as_list.formatted>'
  }
  - announce to_console '<&a>Loaded conversation(s).' format:gpa_gpu_linear_conversation_utility_format

gpa_gpu_linear_conversation_utility_format:
  type: format
  debug: false
  format: '[<&a>GPU<&r> <&2>LCU<&r>] <text>'